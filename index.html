<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Eyes</title>
  <style>
    /* Base styles */
    body {
      margin: 0;
      min-height: 100vh;
      background: #f3f4f6;
      font-family: system-ui, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem;
    }

    .card {
      max-width: 48rem;
      width: 100%;
      background: white;
      border-radius: 1rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      margin: auto; /* Center horizontally */
    }

    .card-header {
      text-align: center;
      padding: 1.5rem;
    }

    .card-title {
      font-size: 2rem;
      font-weight: bold;
    }

    .card-content {
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Eye container */
    .eye-box {
      width: 24rem;
      height: 16rem;
      background: black;
      border-radius: 2rem;
      margin-bottom: 2rem;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: crosshair;
    }

    .eyes {
      display: flex;
      gap: 5rem;
      position: relative;
    }

    .eye-container {
      width: 6rem;
      height: 6rem;
      position: relative;
      overflow: visible;
    }

    .eye {
      width: 6rem;
      height: 6rem;
      background: #3b82f6;
      border-radius: 0.5rem;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Happy expression */
    .eye.happy {
      background: #facc15;
      border-radius: 2rem 2rem 0 0;
      animation: vibrate 0.3s ease-in-out infinite;
    }

    @keyframes vibrate {
      0% { transform: translate(-50%, -50%) translateY(0); }
      50% { transform: translate(-50%, -50%) translateY(-2px); }
      100% { transform: translate(-50%, -50%) translateY(0); }
    }

    .blink {
      height: 0.25rem !important;
      transform: scaleY(0.05) translate(-50%, -50%) !important;
      transition: transform 0.15s cubic-bezier(0.4, 0, 0.2, 1) !important;
    }

    /* Controls */
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.75rem;
      width: 100%;
      max-width: 32rem;
    }

    .control-button {
      padding: 0.75rem;
      background: #e5e7eb;
      border-radius: 0.5rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }

    .control-button:hover {
      background: #d1d5db;
    }

    .control-button.active {
      background: #1f2937;
      color: white;
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div class="card">
    <div class="card-header">
      <div class="card-title">Expressive Robot Eyes</div>
    </div>
    
    <div class="card-content">
      <!-- Eye Display -->
      <div class="eye-box" id="eye-box">
        <div class="eyes">
          <!-- Left Eye -->
          <div class="eye-container">
            <div class="eye" id="left-eye"></div>
          </div>
          
          <!-- Right Eye -->
          <div class="eye-container">
            <div class="eye" id="right-eye"></div>
          </div>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls-grid" id="controls">
        <label>
          <input type="checkbox" id="idle-mode" checked>
          Idle Mode
        </label>

        <button data-dir="center">Center</button>
        <button data-dir="left">Left</button>
        <button data-dir="right">Right</button>
        <button data-dir="up">Up</button>
        <button data-dir="down">Down</button>
        <button data-dir="up-left">Up-Left</button>
        <button data-dir="up-right">Up-Right</button>
        <button data-dir="down-left">Down-Left</button>
        <button data-dir="down-right">Down-Right</button>
        <button data-dir="wide-left">Wide Left</button>
        <button data-dir="wide-right">Wide Right</button>
        <button data-dir="wide-up">Wide Up</button>
        <button data-dir="wide-down">Wide Down</button>
        <button data-expr="happy">ðŸ˜„ Happy</button>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const LOOK_DIRECTIONS = {
        center: 'translate(0, 0)',
        left: 'translateX(-2rem)',
        right: 'translateX(2rem)',
        up: 'translateY(-2rem)',
        down: 'translateY(2rem)',
        'up-left': 'translate(-2rem, -2rem)',
        'up-right': 'translate(2rem, -2rem)',
        'down-left': 'translate(-2rem, 2rem)',
        'down-right': 'translate(2rem, 2rem)',
        'wide-left': 'translateX(-3rem)',
        'wide-right': 'translateX(3rem)',
        'wide-up': 'translateY(-3rem)',
        'wide-down': 'translateY(3rem)'
      };

      let isBlinking = false;
      let lookDirection = 'center';
      let isIdleMode = true;
      let idleTimer = null;
      let isExpressionActive = false;

      const leftEye = document.getElementById('left-eye');
      const rightEye = document.getElementById('right-eye');
      const idleMode = document.getElementById('idle-mode');

      if (!leftEye || !rightEye || !idleMode) {
        console.error('Required DOM elements not found!');
        return;
      }

      function clearIdleTimer() {
        if (idleTimer) {
          clearTimeout(idleTimer);
          idleTimer = null;
        }
      }

      function setEyePosition(direction) {
        // Removed the condition blocking non-center directions during idle mode
        const transform = LOOK_DIRECTIONS[direction] || 'translate(0, 0)';
        const fullTransform = `translate(-50%, -50%) ${transform}`;
        leftEye.style.transform = fullTransform;
        rightEye.style.transform = fullTransform;

        document.querySelectorAll('[data-dir]').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.dir === direction);
        });
      }

      function setupBlinking() {
        const blink = () => {
          if (isBlinking) return;
          isBlinking = true;
          leftEye.classList.add('blink');
          rightEye.classList.add('blink');

          setTimeout(() => {
            leftEye.classList.remove('blink');
            rightEye.classList.remove('blink');
            isBlinking = false;
          }, 150);

          setTimeout(blink, Math.random() * 2000 + 2000);
        };
        
        setTimeout(blink, Math.random() * 1500 + 1000);
      }

      function setupIdleMovement() {
        if (!isIdleMode) {
          clearIdleTimer();
          setEyePosition('center');
          return;
        }

        const directions = Object.keys(LOOK_DIRECTIONS);
        
        const moveEyes = () => {
          let newDirection;
          do {
            newDirection = directions[Math.floor(Math.random() * directions.length)];
          } while (newDirection === lookDirection && Math.random() > 0.3);

          lookDirection = newDirection;
          setEyePosition(newDirection);
          
          const nextMove = Math.random() * 2000 + 1500;
          idleTimer = setTimeout(moveEyes, nextMove);
        };

        // Initial delay
        const initialDelay = Math.random() * 1500 + 1000;
        idleTimer = setTimeout(moveEyes, initialDelay);
      }

      // Manual control and expressions
      document.getElementById('controls').addEventListener('click', function (e) {
        const exprBtn = e.target.closest('[data-expr]');
        if (exprBtn) {
          const expression = exprBtn.dataset.expr;

          if (expression === 'happy') {
            isExpressionActive = true;

            leftEye.className = 'eye happy';
            rightEye.className = 'eye happy';

            // Use wide-up direction from LOOK_DIRECTIONS
            const wideUpTransform = LOOK_DIRECTIONS['wide-up'];
            leftEye.style.transform = `translate(-50%, -50%) ${wideUpTransform}`;
            rightEye.style.transform = `translate(-50%, -50%) ${wideUpTransform}`;

            document.querySelectorAll('[data-dir]').forEach(btn => {
              btn.disabled = true;
            });

            setTimeout(() => {
              isExpressionActive = false;
              leftEye.className = 'eye';
              rightEye.className = 'eye';
              setEyePosition('center');
              document.querySelectorAll('[data-dir]').forEach(btn => {
                btn.disabled = false;
              });
            }, 5000);
          }
          return;
        }

        const dirBtn = e.target.closest('[data-dir]');
        if (dirBtn) {
          const direction = dirBtn.dataset.dir;
          
          if (direction === 'center') {
            isIdleMode = false;
            idleMode.checked = false;
            clearIdleTimer();
            lookDirection = direction;
            setEyePosition(direction);
            return;
          }
          
          if (!isIdleMode && !isExpressionActive) {
            lookDirection = direction;
            setEyePosition(direction);
          }
        }
      });

      // Full-screen mouse tracking
      document.body.addEventListener('mousemove', function(e) {
        if (isIdleMode || isExpressionActive) return;
        
        const rect = document.getElementById('eye-box').getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const x = e.clientX;
        const y = e.clientY;
        
        let direction = 'center';

        if (x < centerX - 100 && y < centerY - 60) direction = 'up-left';
        else if (x > centerX + 100 && y < centerY - 60) direction = 'up-right';
        else if (x < centerX - 100 && y > centerY + 60) direction = 'down-left';
        else if (x > centerX + 100 && y > centerY + 60) direction = 'down-right';
        else if (x < centerX - 60) direction = 'left';
        else if (x > centerX + 60) direction = 'right';
        else if (y < centerY - 60) direction = 'up';
        else if (y > centerY + 60) direction = 'down';

        setEyePosition(direction);
      });

      // Idle mode toggle
      idleMode.addEventListener('change', function() {
        isIdleMode = this.checked;
        if (isIdleMode) {
          setupIdleMovement();
        } else {
          clearIdleTimer();
          setEyePosition('center');
        }
      });

      // Initial setup
      setupBlinking();
      setupIdleMovement();
    });
  </script>
</body>
</html>
